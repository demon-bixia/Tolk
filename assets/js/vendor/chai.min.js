(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.chai = f()
    }
})(function () {
    var define, module, exports;
    return (function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a
                    }
                    var p = n[i] = {exports: {}};
                    e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];
                        return o(n || r)
                    }, p, p.exports, r, e, n, t)
                }
                return n[i].exports
            }

            for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o
        }

        return r
    })()({
        1: [function (require, module, exports) {
            module.exports = require('./lib/chai')
        }, {"./lib/chai": 2}],
        2: [function (require, module, exports) {
            var used = [];
            exports.version = '4.2.0';
            exports.AssertionError = require('assertion-error');
            var util = require('./chai/utils');
            exports.use = function (fn) {
                if (!~used.indexOf(fn)) {
                    fn(exports, util);
                    used.push(fn)
                }
                return exports
            };
            exports.util = util;
            var config = require('./chai/config');
            exports.config = config;
            var assertion = require('./chai/assertion');
            exports.use(assertion);
            var core = require('./chai/core/assertions');
            exports.use(core);
            var expect = require('./chai/interface/expect');
            exports.use(expect);
            var should = require('./chai/interface/should');
            exports.use(should);
            var assert = require('./chai/interface/assert');
            exports.use(assert)
        }, {
            "./chai/assertion": 3,
            "./chai/config": 4,
            "./chai/core/assertions": 5,
            "./chai/interface/assert": 6,
            "./chai/interface/expect": 7,
            "./chai/interface/should": 8,
            "./chai/utils": 22,
            "assertion-error": 33
        }],
        3: [function (require, module, exports) {
            var config = require('./config');
            module.exports = function (_chai, util) {
                var AssertionError = _chai.AssertionError, flag = util.flag;
                _chai.Assertion = Assertion;

                function Assertion(obj, msg, ssfi, lockSsfi) {
                    flag(this, 'ssfi', ssfi || Assertion);
                    flag(this, 'lockSsfi', lockSsfi);
                    flag(this, 'object', obj);
                    flag(this, 'message', msg);
                    return util.proxify(this)
                }

                Object.defineProperty(Assertion, 'includeStack', {
                    get: function () {
                        console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
                        return config.includeStack
                    }, set: function (value) {
                        console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
                        config.includeStack = value
                    }
                });
                Object.defineProperty(Assertion, 'showDiff', {
                    get: function () {
                        console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
                        return config.showDiff
                    }, set: function (value) {
                        console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
                        config.showDiff = value
                    }
                });
                Assertion.addProperty = function (name, fn) {
                    util.addProperty(this.prototype, name, fn)
                };
                Assertion.addMethod = function (name, fn) {
                    util.addMethod(this.prototype, name, fn)
                };
                Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
                    util.addChainableMethod(this.prototype, name, fn, chainingBehavior)
                };
                Assertion.overwriteProperty = function (name, fn) {
                    util.overwriteProperty(this.prototype, name, fn)
                };
                Assertion.overwriteMethod = function (name, fn) {
                    util.overwriteMethod(this.prototype, name, fn)
                };
                Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
                    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior)
                };
                Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
                    var ok = util.test(this, arguments);
                    if (!1 !== showDiff) showDiff = !0;
                    if (undefined === expected && undefined === _actual) showDiff = !1;
                    if (!0 !== config.showDiff) showDiff = !1;
                    if (!ok) {
                        msg = util.getMessage(this, arguments);
                        var actual = util.getActual(this, arguments);
                        throw new AssertionError(msg, {
                            actual: actual,
                            expected: expected,
                            showDiff: showDiff
                        }, (config.includeStack) ? this.assert : flag(this, 'ssfi'))
                    }
                };
                Object.defineProperty(Assertion.prototype, '_obj', {
                    get: function () {
                        return flag(this, 'object')
                    }, set: function (val) {
                        flag(this, 'object', val)
                    }
                })
            }
        }, {"./config": 4}],
        4: [function (require, module, exports) {
            module.exports = {
                includeStack: !1,
                showDiff: !0,
                truncateThreshold: 40,
                useProxy: !0,
                proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
            }
        }, {}],
        5: [function (require, module, exports) {
            module.exports = function (chai, _) {
                var Assertion = chai.Assertion, AssertionError = chai.AssertionError, flag = _.flag;
                ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does', 'still'].forEach(function (chain) {
                    Assertion.addProperty(chain)
                });
                Assertion.addProperty('not', function () {
                    flag(this, 'negate', !0)
                });
                Assertion.addProperty('deep', function () {
                    flag(this, 'deep', !0)
                });
                Assertion.addProperty('nested', function () {
                    flag(this, 'nested', !0)
                });
                Assertion.addProperty('own', function () {
                    flag(this, 'own', !0)
                });
                Assertion.addProperty('ordered', function () {
                    flag(this, 'ordered', !0)
                });
                Assertion.addProperty('any', function () {
                    flag(this, 'any', !0);
                    flag(this, 'all', !1)
                });
                Assertion.addProperty('all', function () {
                    flag(this, 'all', !0);
                    flag(this, 'any', !1)
                });

                function an(type, msg) {
                    if (msg) flag(this, 'message', msg);
                    type = type.toLowerCase();
                    var obj = flag(this, 'object'),
                        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
                    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type)
                }

                Assertion.addChainableMethod('an', an);
                Assertion.addChainableMethod('a', an);

                function SameValueZero(a, b) {
                    return (_.isNaN(a) && _.isNaN(b)) || a === b
                }

                function includeChainingBehavior() {
                    flag(this, 'contains', !0)
                }

                function include(val, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), objType = _.type(obj).toLowerCase(),
                        flagMsg = flag(this, 'message'), negate = flag(this, 'negate'), ssfi = flag(this, 'ssfi'),
                        isDeep = flag(this, 'deep'), descriptor = isDeep ? 'deep ' : '';
                    flagMsg = flagMsg ? flagMsg + ': ' : '';
                    var included = !1;
                    switch (objType) {
                        case 'string':
                            included = obj.indexOf(val) !== -1;
                            break;
                        case 'weakset':
                            if (isDeep) {
                                throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi)
                            }
                            included = obj.has(val);
                            break;
                        case 'map':
                            var isEql = isDeep ? _.eql : SameValueZero;
                            obj.forEach(function (item) {
                                included = included || isEql(item, val)
                            });
                            break;
                        case 'set':
                            if (isDeep) {
                                obj.forEach(function (item) {
                                    included = included || _.eql(item, val)
                                })
                            } else {
                                included = obj.has(val)
                            }
                            break;
                        case 'array':
                            if (isDeep) {
                                included = obj.some(function (item) {
                                    return _.eql(item, val)
                                })
                            } else {
                                included = obj.indexOf(val) !== -1
                            }
                            break;
                        default:
                            if (val !== Object(val)) {
                                throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi)
                            }
                            var props = Object.keys(val), firstErr = null, numErrs = 0;
                            props.forEach(function (prop) {
                                var propAssertion = new Assertion(obj);
                                _.transferFlags(this, propAssertion, !0);
                                flag(propAssertion, 'lockSsfi', !0);
                                if (!negate || props.length === 1) {
                                    propAssertion.property(prop, val[prop]);
                                    return
                                }
                                try {
                                    propAssertion.property(prop, val[prop])
                                } catch (err) {
                                    if (!_.checkError.compatibleConstructor(err, AssertionError)) {
                                        throw err
                                    }
                                    if (firstErr === null) firstErr = err;
                                    numErrs++
                                }
                            }, this);
                            if (negate && props.length > 1 && numErrs === props.length) {
                                throw firstErr
                            }
                            return
                    }
                    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val))
                }

                Assertion.addChainableMethod('include', include, includeChainingBehavior);
                Assertion.addChainableMethod('contain', include, includeChainingBehavior);
                Assertion.addChainableMethod('contains', include, includeChainingBehavior);
                Assertion.addChainableMethod('includes', include, includeChainingBehavior);
                Assertion.addProperty('ok', function () {
                    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy')
                });
                Assertion.addProperty('true', function () {
                    this.assert(!0 === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? !1 : !0)
                });
                Assertion.addProperty('false', function () {
                    this.assert(!1 === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? !0 : !1)
                });
                Assertion.addProperty('null', function () {
                    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null')
                });
                Assertion.addProperty('undefined', function () {
                    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined')
                });
                Assertion.addProperty('NaN', function () {
                    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN')
                });
                Assertion.addProperty('exist', function () {
                    var val = flag(this, 'object');
                    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist')
                });
                Assertion.addProperty('empty', function () {
                    var val = flag(this, 'object'), ssfi = flag(this, 'ssfi'), flagMsg = flag(this, 'message'),
                        itemsCount;
                    flagMsg = flagMsg ? flagMsg + ': ' : '';
                    switch (_.type(val).toLowerCase()) {
                        case 'array':
                        case 'string':
                            itemsCount = val.length;
                            break;
                        case 'map':
                        case 'set':
                            itemsCount = val.size;
                            break;
                        case 'weakmap':
                        case 'weakset':
                            throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);
                        case 'function':
                            var msg = flagMsg + '.empty was passed a function ' + _.getName(val);
                            throw new AssertionError(msg.trim(), undefined, ssfi);
                        default:
                            if (val !== Object(val)) {
                                throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi)
                            }
                            itemsCount = Object.keys(val).length
                    }
                    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty')
                });

                function checkArguments() {
                    var obj = flag(this, 'object'), type = _.type(obj);
                    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments')
                }

                Assertion.addProperty('arguments', checkArguments);
                Assertion.addProperty('Arguments', checkArguments);

                function assertEqual(val, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object');
                    if (flag(this, 'deep')) {
                        var prevLockSsfi = flag(this, 'lockSsfi');
                        flag(this, 'lockSsfi', !0);
                        this.eql(val);
                        flag(this, 'lockSsfi', prevLockSsfi)
                    } else {
                        this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, !0)
                    }
                }

                Assertion.addMethod('equal', assertEqual);
                Assertion.addMethod('equals', assertEqual);
                Assertion.addMethod('eq', assertEqual);

                function assertEql(obj, msg) {
                    if (msg) flag(this, 'message', msg);
                    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, !0)
                }

                Assertion.addMethod('eql', assertEql);
                Assertion.addMethod('eqls', assertEql);

                function assertAbove(n, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), doLength = flag(this, 'doLength'), flagMsg = flag(this, 'message'),
                        msgPrefix = ((flagMsg) ? flagMsg + ': ' : ''), ssfi = flag(this, 'ssfi'),
                        objType = _.type(obj).toLowerCase(), nType = _.type(n).toLowerCase(), errorMessage,
                        shouldThrow = !0;
                    if (doLength && objType !== 'map' && objType !== 'set') {
                        new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length')
                    }
                    if (!doLength && (objType === 'date' && nType !== 'date')) {
                        errorMessage = msgPrefix + 'the argument to above must be a date'
                    } else if (nType !== 'number' && (doLength || objType === 'number')) {
                        errorMessage = msgPrefix + 'the argument to above must be a number'
                    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
                        var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
                        errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date'
                    } else {
                        shouldThrow = !1
                    }
                    if (shouldThrow) {
                        throw new AssertionError(errorMessage, undefined, ssfi)
                    }
                    if (doLength) {
                        var descriptor = 'length', itemsCount;
                        if (objType === 'map' || objType === 'set') {
                            descriptor = 'size';
                            itemsCount = obj.size
                        } else {
                            itemsCount = obj.length
                        }
                        this.assert(itemsCount > n, 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' above #{exp}', n, itemsCount)
                    } else {
                        this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n)
                    }
                }

                Assertion.addMethod('above', assertAbove);
                Assertion.addMethod('gt', assertAbove);
                Assertion.addMethod('greaterThan', assertAbove);

                function assertLeast(n, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), doLength = flag(this, 'doLength'), flagMsg = flag(this, 'message'),
                        msgPrefix = ((flagMsg) ? flagMsg + ': ' : ''), ssfi = flag(this, 'ssfi'),
                        objType = _.type(obj).toLowerCase(), nType = _.type(n).toLowerCase(), errorMessage,
                        shouldThrow = !0;
                    if (doLength && objType !== 'map' && objType !== 'set') {
                        new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length')
                    }
                    if (!doLength && (objType === 'date' && nType !== 'date')) {
                        errorMessage = msgPrefix + 'the argument to least must be a date'
                    } else if (nType !== 'number' && (doLength || objType === 'number')) {
                        errorMessage = msgPrefix + 'the argument to least must be a number'
                    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
                        var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
                        errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date'
                    } else {
                        shouldThrow = !1
                    }
                    if (shouldThrow) {
                        throw new AssertionError(errorMessage, undefined, ssfi)
                    }
                    if (doLength) {
                        var descriptor = 'length', itemsCount;
                        if (objType === 'map' || objType === 'set') {
                            descriptor = 'size';
                            itemsCount = obj.size
                        } else {
                            itemsCount = obj.length
                        }
                        this.assert(itemsCount >= n, 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' below #{exp}', n, itemsCount)
                    } else {
                        this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n)
                    }
                }

                Assertion.addMethod('least', assertLeast);
                Assertion.addMethod('gte', assertLeast);

                function assertBelow(n, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), doLength = flag(this, 'doLength'), flagMsg = flag(this, 'message'),
                        msgPrefix = ((flagMsg) ? flagMsg + ': ' : ''), ssfi = flag(this, 'ssfi'),
                        objType = _.type(obj).toLowerCase(), nType = _.type(n).toLowerCase(), errorMessage,
                        shouldThrow = !0;
                    if (doLength && objType !== 'map' && objType !== 'set') {
                        new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length')
                    }
                    if (!doLength && (objType === 'date' && nType !== 'date')) {
                        errorMessage = msgPrefix + 'the argument to below must be a date'
                    } else if (nType !== 'number' && (doLength || objType === 'number')) {
                        errorMessage = msgPrefix + 'the argument to below must be a number'
                    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
                        var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
                        errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date'
                    } else {
                        shouldThrow = !1
                    }
                    if (shouldThrow) {
                        throw new AssertionError(errorMessage, undefined, ssfi)
                    }
                    if (doLength) {
                        var descriptor = 'length', itemsCount;
                        if (objType === 'map' || objType === 'set') {
                            descriptor = 'size';
                            itemsCount = obj.size
                        } else {
                            itemsCount = obj.length
                        }
                        this.assert(itemsCount < n, 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' below #{exp}', n, itemsCount)
                    } else {
                        this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n)
                    }
                }

                Assertion.addMethod('below', assertBelow);
                Assertion.addMethod('lt', assertBelow);
                Assertion.addMethod('lessThan', assertBelow);

                function assertMost(n, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), doLength = flag(this, 'doLength'), flagMsg = flag(this, 'message'),
                        msgPrefix = ((flagMsg) ? flagMsg + ': ' : ''), ssfi = flag(this, 'ssfi'),
                        objType = _.type(obj).toLowerCase(), nType = _.type(n).toLowerCase(), errorMessage,
                        shouldThrow = !0;
                    if (doLength && objType !== 'map' && objType !== 'set') {
                        new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length')
                    }
                    if (!doLength && (objType === 'date' && nType !== 'date')) {
                        errorMessage = msgPrefix + 'the argument to most must be a date'
                    } else if (nType !== 'number' && (doLength || objType === 'number')) {
                        errorMessage = msgPrefix + 'the argument to most must be a number'
                    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
                        var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
                        errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date'
                    } else {
                        shouldThrow = !1
                    }
                    if (shouldThrow) {
                        throw new AssertionError(errorMessage, undefined, ssfi)
                    }
                    if (doLength) {
                        var descriptor = 'length', itemsCount;
                        if (objType === 'map' || objType === 'set') {
                            descriptor = 'size';
                            itemsCount = obj.size
                        } else {
                            itemsCount = obj.length
                        }
                        this.assert(itemsCount <= n, 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' above #{exp}', n, itemsCount)
                    } else {
                        this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n)
                    }
                }

                Assertion.addMethod('most', assertMost);
                Assertion.addMethod('lte', assertMost);
                Assertion.addMethod('within', function (start, finish, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), doLength = flag(this, 'doLength'), flagMsg = flag(this, 'message'),
                        msgPrefix = ((flagMsg) ? flagMsg + ': ' : ''), ssfi = flag(this, 'ssfi'),
                        objType = _.type(obj).toLowerCase(), startType = _.type(start).toLowerCase(),
                        finishType = _.type(finish).toLowerCase(), errorMessage, shouldThrow = !0,
                        range = (startType === 'date' && finishType === 'date') ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;
                    if (doLength && objType !== 'map' && objType !== 'set') {
                        new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length')
                    }
                    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {
                        errorMessage = msgPrefix + 'the arguments to within must be dates'
                    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
                        errorMessage = msgPrefix + 'the arguments to within must be numbers'
                    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
                        var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
                        errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date'
                    } else {
                        shouldThrow = !1
                    }
                    if (shouldThrow) {
                        throw new AssertionError(errorMessage, undefined, ssfi)
                    }
                    if (doLength) {
                        var descriptor = 'length', itemsCount;
                        if (objType === 'map' || objType === 'set') {
                            descriptor = 'size';
                            itemsCount = obj.size
                        } else {
                            itemsCount = obj.length
                        }
                        this.assert(itemsCount >= start && itemsCount <= finish, 'expected #{this} to have a ' + descriptor + ' within ' + range, 'expected #{this} to not have a ' + descriptor + ' within ' + range)
                    } else {
                        this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range)
                    }
                });

                function assertInstanceOf(constructor, msg) {
                    if (msg) flag(this, 'message', msg);
                    var target = flag(this, 'object')
                    var ssfi = flag(this, 'ssfi');
                    var flagMsg = flag(this, 'message');
                    try {
                        var isInstanceOf = target instanceof constructor
                    } catch (err) {
                        if (err instanceof TypeError) {
                            flagMsg = flagMsg ? flagMsg + ': ' : '';
                            throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi)
                        }
                        throw err
                    }
                    var name = _.getName(constructor);
                    if (name === null) {
                        name = 'an unnamed constructor'
                    }
                    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name)
                };Assertion.addMethod('instanceof', assertInstanceOf);
                Assertion.addMethod('instanceOf', assertInstanceOf);

                function assertProperty(name, val, msg) {
                    if (msg) flag(this, 'message', msg);
                    var isNested = flag(this, 'nested'), isOwn = flag(this, 'own'), flagMsg = flag(this, 'message'),
                        obj = flag(this, 'object'), ssfi = flag(this, 'ssfi'), nameType = typeof name;
                    flagMsg = flagMsg ? flagMsg + ': ' : '';
                    if (isNested) {
                        if (nameType !== 'string') {
                            throw new AssertionError(flagMsg + 'the argument to property must be a string when using nested syntax', undefined, ssfi)
                        }
                    } else {
                        if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
                            throw new AssertionError(flagMsg + 'the argument to property must be a string, number, or symbol', undefined, ssfi)
                        }
                    }
                    if (isNested && isOwn) {
                        throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi)
                    }
                    if (obj === null || obj === undefined) {
                        throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi)
                    }
                    var isDeep = flag(this, 'deep'), negate = flag(this, 'negate'),
                        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
                        value = isNested ? pathInfo.value : obj[name];
                    var descriptor = '';
                    if (isDeep) descriptor += 'deep ';
                    if (isOwn) descriptor += 'own ';
                    if (isNested) descriptor += 'nested ';
                    descriptor += 'property ';
                    var hasProperty;
                    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name); else if (isNested) hasProperty = pathInfo.exists; else hasProperty = _.hasProperty(obj, name);
                    if (!negate || arguments.length === 1) {
                        this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name))
                    }
                    if (arguments.length > 1) {
                        this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value)
                    }
                    flag(this, 'object', value)
                }

                Assertion.addMethod('property', assertProperty);

                function assertOwnProperty(name, value, msg) {
                    flag(this, 'own', !0);
                    assertProperty.apply(this, arguments)
                }

                Assertion.addMethod('ownProperty', assertOwnProperty);
                Assertion.addMethod('haveOwnProperty', assertOwnProperty);

                function assertOwnPropertyDescriptor(name, descriptor, msg) {
                    if (typeof descriptor === 'string') {
                        msg = descriptor;
                        descriptor = null
                    }
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object');
                    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
                    if (actualDescriptor && descriptor) {
                        this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, !0)
                    } else {
                        this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name))
                    }
                    flag(this, 'object', actualDescriptor)
                }

                Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
                Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

                function assertLengthChain() {
                    flag(this, 'doLength', !0)
                }

                function assertLength(n, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), objType = _.type(obj).toLowerCase(),
                        flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi'), descriptor = 'length', itemsCount;
                    switch (objType) {
                        case 'map':
                        case 'set':
                            descriptor = 'size';
                            itemsCount = obj.size;
                            break;
                        default:
                            new Assertion(obj, flagMsg, ssfi, !0).to.have.property('length');
                            itemsCount = obj.length
                    }
                    this.assert(itemsCount == n, 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' of #{act}', n, itemsCount)
                }

                Assertion.addChainableMethod('length', assertLength, assertLengthChain);
                Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);

                function assertMatch(re, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object');
                    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re)
                }

                Assertion.addMethod('match', assertMatch);
                Assertion.addMethod('matches', assertMatch);
                Assertion.addMethod('string', function (str, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(obj, flagMsg, ssfi, !0).is.a('string');
                    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str))
                });

                function assertKeys(keys) {
                    var obj = flag(this, 'object'), objType = _.type(obj), keysType = _.type(keys),
                        ssfi = flag(this, 'ssfi'), isDeep = flag(this, 'deep'), str, deepStr = '', actual, ok = !0,
                        flagMsg = flag(this, 'message');
                    flagMsg = flagMsg ? flagMsg + ': ' : '';
                    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';
                    if (objType === 'Map' || objType === 'Set') {
                        deepStr = isDeep ? 'deeply ' : '';
                        actual = [];
                        obj.forEach(function (val, key) {
                            actual.push(key)
                        });
                        if (keysType !== 'Array') {
                            keys = Array.prototype.slice.call(arguments)
                        }
                    } else {
                        actual = _.getOwnEnumerableProperties(obj);
                        switch (keysType) {
                            case 'Array':
                                if (arguments.length > 1) {
                                    throw new AssertionError(mixedArgsMsg, undefined, ssfi)
                                }
                                break;
                            case 'Object':
                                if (arguments.length > 1) {
                                    throw new AssertionError(mixedArgsMsg, undefined, ssfi)
                                }
                                keys = Object.keys(keys);
                                break;
                            default:
                                keys = Array.prototype.slice.call(arguments)
                        }
                        keys = keys.map(function (val) {
                            return typeof val === 'symbol' ? val : String(val)
                        })
                    }
                    if (!keys.length) {
                        throw new AssertionError(flagMsg + 'keys required', undefined, ssfi)
                    }
                    var len = keys.length, any = flag(this, 'any'), all = flag(this, 'all'), expected = keys;
                    if (!any && !all) {
                        all = !0
                    }
                    if (any) {
                        ok = expected.some(function (expectedKey) {
                            return actual.some(function (actualKey) {
                                if (isDeep) {
                                    return _.eql(expectedKey, actualKey)
                                } else {
                                    return expectedKey === actualKey
                                }
                            })
                        })
                    }
                    if (all) {
                        ok = expected.every(function (expectedKey) {
                            return actual.some(function (actualKey) {
                                if (isDeep) {
                                    return _.eql(expectedKey, actualKey)
                                } else {
                                    return expectedKey === actualKey
                                }
                            })
                        });
                        if (!flag(this, 'contains')) {
                            ok = ok && keys.length == actual.length
                        }
                    }
                    if (len > 1) {
                        keys = keys.map(function (key) {
                            return _.inspect(key)
                        });
                        var last = keys.pop();
                        if (all) {
                            str = keys.join(', ') + ', and ' + last
                        }
                        if (any) {
                            str = keys.join(', ') + ', or ' + last
                        }
                    } else {
                        str = _.inspect(keys[0])
                    }
                    str = (len > 1 ? 'keys ' : 'key ') + str;
                    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;
                    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), !0)
                }

                Assertion.addMethod('keys', assertKeys);
                Assertion.addMethod('key', assertKeys);

                function assertThrows(errorLike, errMsgMatcher, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), ssfi = flag(this, 'ssfi'), flagMsg = flag(this, 'message'),
                        negate = flag(this, 'negate') || !1;
                    new Assertion(obj, flagMsg, ssfi, !0).is.a('function');
                    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
                        errMsgMatcher = errorLike;
                        errorLike = null
                    }
                    var caughtErr;
                    try {
                        obj()
                    } catch (err) {
                        caughtErr = err
                    }
                    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;
                    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
                    var errorLikeFail = !1;
                    var errMsgMatcherFail = !1;
                    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
                        var errorLikeString = 'an error';
                        if (errorLike instanceof Error) {
                            errorLikeString = '#{exp}'
                        } else if (errorLike) {
                            errorLikeString = _.checkError.getConstructorName(errorLike)
                        }
                        this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), (caughtErr instanceof Error ? caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr))))
                    }
                    if (errorLike && caughtErr) {
                        if (errorLike instanceof Error) {
                            var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);
                            if (isCompatibleInstance === negate) {
                                if (everyArgIsDefined && negate) {
                                    errorLikeFail = !0
                                } else {
                                    this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString())
                                }
                            }
                        }
                        var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
                        if (isCompatibleConstructor === negate) {
                            if (everyArgIsDefined && negate) {
                                errorLikeFail = !0
                            } else {
                                this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike)), (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr)))
                            }
                        }
                    }
                    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
                        var placeholder = 'including';
                        if (errMsgMatcher instanceof RegExp) {
                            placeholder = 'matching'
                        }
                        var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
                        if (isCompatibleMessage === negate) {
                            if (everyArgIsDefined && negate) {
                                errMsgMatcherFail = !0
                            } else {
                                this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr))
                            }
                        }
                    }
                    if (errorLikeFail && errMsgMatcherFail) {
                        this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike)), (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr)))
                    }
                    flag(this, 'object', caughtErr)
                };Assertion.addMethod('throw', assertThrows);
                Assertion.addMethod('throws', assertThrows);
                Assertion.addMethod('Throw', assertThrows);

                function respondTo(method, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), itself = flag(this, 'itself'),
                        context = ('function' === typeof obj && !itself) ? obj.prototype[method] : obj[method];
                    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method))
                }

                Assertion.addMethod('respondTo', respondTo);
                Assertion.addMethod('respondsTo', respondTo);
                Assertion.addProperty('itself', function () {
                    flag(this, 'itself', !0)
                });

                function satisfy(matcher, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object');
                    var result = matcher(obj);
                    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? !1 : !0, result)
                }

                Assertion.addMethod('satisfy', satisfy);
                Assertion.addMethod('satisfies', satisfy);

                function closeTo(expected, delta, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(obj, flagMsg, ssfi, !0).is.a('number');
                    if (typeof expected !== 'number' || typeof delta !== 'number') {
                        flagMsg = flagMsg ? flagMsg + ': ' : '';
                        throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi)
                    }
                    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta)
                }

                Assertion.addMethod('closeTo', closeTo);
                Assertion.addMethod('approximately', closeTo);

                function isSubsetOf(subset, superset, cmp, contains, ordered) {
                    if (!contains) {
                        if (subset.length !== superset.length) return !1;
                        superset = superset.slice()
                    }
                    return subset.every(function (elem, idx) {
                        if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
                        if (!cmp) {
                            var matchIdx = superset.indexOf(elem);
                            if (matchIdx === -1) return !1;
                            if (!contains) superset.splice(matchIdx, 1);
                            return !0
                        }
                        return superset.some(function (elem2, matchIdx) {
                            if (!cmp(elem, elem2)) return !1;
                            if (!contains) superset.splice(matchIdx, 1);
                            return !0
                        })
                    })
                }

                Assertion.addMethod('members', function (subset, msg) {
                    if (msg) flag(this, 'message', msg);
                    var obj = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(obj, flagMsg, ssfi, !0).to.be.an('array');
                    new Assertion(subset, flagMsg, ssfi, !0).to.be.an('array');
                    var contains = flag(this, 'contains');
                    var ordered = flag(this, 'ordered');
                    var subject, failMsg, failNegateMsg;
                    if (contains) {
                        subject = ordered ? 'an ordered superset' : 'a superset';
                        failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
                        failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}'
                    } else {
                        subject = ordered ? 'ordered members' : 'members';
                        failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
                        failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}'
                    }
                    var cmp = flag(this, 'deep') ? _.eql : undefined;
                    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, !0)
                });

                function oneOf(list, msg) {
                    if (msg) flag(this, 'message', msg);
                    var expected = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(list, flagMsg, ssfi, !0).to.be.an('array');
                    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected)
                }

                Assertion.addMethod('oneOf', oneOf);

                function assertChanges(subject, prop, msg) {
                    if (msg) flag(this, 'message', msg);
                    var fn = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(fn, flagMsg, ssfi, !0).is.a('function');
                    var initial;
                    if (!prop) {
                        new Assertion(subject, flagMsg, ssfi, !0).is.a('function');
                        initial = subject()
                    } else {
                        new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop);
                        initial = subject[prop]
                    }
                    fn();
                    var final = prop === undefined || prop === null ? subject() : subject[prop];
                    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
                    flag(this, 'deltaMsgObj', msgObj);
                    flag(this, 'initialDeltaValue', initial);
                    flag(this, 'finalDeltaValue', final);
                    flag(this, 'deltaBehavior', 'change');
                    flag(this, 'realDelta', final !== initial);
                    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change')
                }

                Assertion.addMethod('change', assertChanges);
                Assertion.addMethod('changes', assertChanges);

                function assertIncreases(subject, prop, msg) {
                    if (msg) flag(this, 'message', msg);
                    var fn = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(fn, flagMsg, ssfi, !0).is.a('function');
                    var initial;
                    if (!prop) {
                        new Assertion(subject, flagMsg, ssfi, !0).is.a('function');
                        initial = subject()
                    } else {
                        new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop);
                        initial = subject[prop]
                    }
                    new Assertion(initial, flagMsg, ssfi, !0).is.a('number');
                    fn();
                    var final = prop === undefined || prop === null ? subject() : subject[prop];
                    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
                    flag(this, 'deltaMsgObj', msgObj);
                    flag(this, 'initialDeltaValue', initial);
                    flag(this, 'finalDeltaValue', final);
                    flag(this, 'deltaBehavior', 'increase');
                    flag(this, 'realDelta', final - initial);
                    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase')
                }

                Assertion.addMethod('increase', assertIncreases);
                Assertion.addMethod('increases', assertIncreases);

                function assertDecreases(subject, prop, msg) {
                    if (msg) flag(this, 'message', msg);
                    var fn = flag(this, 'object'), flagMsg = flag(this, 'message'), ssfi = flag(this, 'ssfi');
                    new Assertion(fn, flagMsg, ssfi, !0).is.a('function');
                    var initial;
                    if (!prop) {
                        new Assertion(subject, flagMsg, ssfi, !0).is.a('function');
                        initial = subject()
                    } else {
                        new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop);
                        initial = subject[prop]
                    }
                    new Assertion(initial, flagMsg, ssfi, !0).is.a('number');
                    fn();
                    var final = prop === undefined || prop === null ? subject() : subject[prop];
                    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
                    flag(this, 'deltaMsgObj', msgObj);
                    flag(this, 'initialDeltaValue', initial);
                    flag(this, 'finalDeltaValue', final);
                    flag(this, 'deltaBehavior', 'decrease');
                    flag(this, 'realDelta', initial - final);
                    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease')
                }

                Assertion.addMethod('decrease', assertDecreases);
                Assertion.addMethod('decreases', assertDecreases);

                function assertDelta(delta, msg) {
                    if (msg) flag(this, 'message', msg);
                    var msgObj = flag(this, 'deltaMsgObj');
                    var initial = flag(this, 'initialDeltaValue');
                    var final = flag(this, 'finalDeltaValue');
                    var behavior = flag(this, 'deltaBehavior');
                    var realDelta = flag(this, 'realDelta');
                    var expression;
                    if (behavior === 'change') {
                        expression = Math.abs(final - initial) === Math.abs(delta)
                    } else {
                        expression = realDelta === Math.abs(delta)
                    }
                    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta)
                }

                Assertion.addMethod('by', assertDelta);
                Assertion.addProperty('extensible', function () {
                    var obj = flag(this, 'object');
                    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
                    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible')
                });
                Assertion.addProperty('sealed', function () {
                    var obj = flag(this, 'object');
                    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : !0;
                    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed')
                });
                Assertion.addProperty('frozen', function () {
                    var obj = flag(this, 'object');
                    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : !0;
                    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen')
                });
                Assertion.addProperty('finite', function (msg) {
                    var obj = flag(this, 'object');
                    this.assert(typeof obj === 'number' && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number')
                })
            }
        }, {}],
        6: [function (require, module, exports) {
            module.exports = function (chai, util) {
                var Assertion = chai.Assertion, flag = util.flag;
                var assert = chai.assert = function (express, errmsg) {
                    var test = new Assertion(null, null, chai.assert, !0);
                    test.assert(express, errmsg, '[ negation message unavailable ]')
                };
                assert.fail = function (actual, expected, message, operator) {
                    if (arguments.length < 2) {
                        message = actual;
                        actual = undefined
                    }
                    message = message || 'assert.fail()';
                    throw new chai.AssertionError(message, {
                        actual: actual,
                        expected: expected,
                        operator: operator
                    }, assert.fail)
                };
                assert.isOk = function (val, msg) {
                    new Assertion(val, msg, assert.isOk, !0).is.ok
                };
                assert.isNotOk = function (val, msg) {
                    new Assertion(val, msg, assert.isNotOk, !0).is.not.ok
                };
                assert.equal = function (act, exp, msg) {
                    var test = new Assertion(act, msg, assert.equal, !0);
                    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, !0)
                };
                assert.notEqual = function (act, exp, msg) {
                    var test = new Assertion(act, msg, assert.notEqual, !0);
                    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, !0)
                };
                assert.strictEqual = function (act, exp, msg) {
                    new Assertion(act, msg, assert.strictEqual, !0).to.equal(exp)
                };
                assert.notStrictEqual = function (act, exp, msg) {
                    new Assertion(act, msg, assert.notStrictEqual, !0).to.not.equal(exp)
                };
                assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
                    new Assertion(act, msg, assert.deepEqual, !0).to.eql(exp)
                };
                assert.notDeepEqual = function (act, exp, msg) {
                    new Assertion(act, msg, assert.notDeepEqual, !0).to.not.eql(exp)
                };
                assert.isAbove = function (val, abv, msg) {
                    new Assertion(val, msg, assert.isAbove, !0).to.be.above(abv)
                };
                assert.isAtLeast = function (val, atlst, msg) {
                    new Assertion(val, msg, assert.isAtLeast, !0).to.be.least(atlst)
                };
                assert.isBelow = function (val, blw, msg) {
                    new Assertion(val, msg, assert.isBelow, !0).to.be.below(blw)
                };
                assert.isAtMost = function (val, atmst, msg) {
                    new Assertion(val, msg, assert.isAtMost, !0).to.be.most(atmst)
                };
                assert.isTrue = function (val, msg) {
                    new Assertion(val, msg, assert.isTrue, !0).is['true']
                };
                assert.isNotTrue = function (val, msg) {
                    new Assertion(val, msg, assert.isNotTrue, !0).to.not.equal(!0)
                };
                assert.isFalse = function (val, msg) {
                    new Assertion(val, msg, assert.isFalse, !0).is['false']
                };
                assert.isNotFalse = function (val, msg) {
                    new Assertion(val, msg, assert.isNotFalse, !0).to.not.equal(!1)
                };
                assert.isNull = function (val, msg) {
                    new Assertion(val, msg, assert.isNull, !0).to.equal(null)
                };
                assert.isNotNull = function (val, msg) {
                    new Assertion(val, msg, assert.isNotNull, !0).to.not.equal(null)
                };
                assert.isNaN = function (val, msg) {
                    new Assertion(val, msg, assert.isNaN, !0).to.be.NaN
                };
                assert.isNotNaN = function (val, msg) {
                    new Assertion(val, msg, assert.isNotNaN, !0).not.to.be.NaN
                };
                assert.exists = function (val, msg) {
                    new Assertion(val, msg, assert.exists, !0).to.exist
                };
                assert.notExists = function (val, msg) {
                    new Assertion(val, msg, assert.notExists, !0).to.not.exist
                };
                assert.isUndefined = function (val, msg) {
                    new Assertion(val, msg, assert.isUndefined, !0).to.equal(undefined)
                };
                assert.isDefined = function (val, msg) {
                    new Assertion(val, msg, assert.isDefined, !0).to.not.equal(undefined)
                };
                assert.isFunction = function (val, msg) {
                    new Assertion(val, msg, assert.isFunction, !0).to.be.a('function')
                };
                assert.isNotFunction = function (val, msg) {
                    new Assertion(val, msg, assert.isNotFunction, !0).to.not.be.a('function')
                };
                assert.isObject = function (val, msg) {
                    new Assertion(val, msg, assert.isObject, !0).to.be.a('object')
                };
                assert.isNotObject = function (val, msg) {
                    new Assertion(val, msg, assert.isNotObject, !0).to.not.be.a('object')
                };
                assert.isArray = function (val, msg) {
                    new Assertion(val, msg, assert.isArray, !0).to.be.an('array')
                };
                assert.isNotArray = function (val, msg) {
                    new Assertion(val, msg, assert.isNotArray, !0).to.not.be.an('array')
                };
                assert.isString = function (val, msg) {
                    new Assertion(val, msg, assert.isString, !0).to.be.a('string')
                };
                assert.isNotString = function (val, msg) {
                    new Assertion(val, msg, assert.isNotString, !0).to.not.be.a('string')
                };
                assert.isNumber = function (val, msg) {
                    new Assertion(val, msg, assert.isNumber, !0).to.be.a('number')
                };
                assert.isNotNumber = function (val, msg) {
                    new Assertion(val, msg, assert.isNotNumber, !0).to.not.be.a('number')
                };
                assert.isFinite = function (val, msg) {
                    new Assertion(val, msg, assert.isFinite, !0).to.be.finite
                };
                assert.isBoolean = function (val, msg) {
                    new Assertion(val, msg, assert.isBoolean, !0).to.be.a('boolean')
                };
                assert.isNotBoolean = function (val, msg) {
                    new Assertion(val, msg, assert.isNotBoolean, !0).to.not.be.a('boolean')
                };
                assert.typeOf = function (val, type, msg) {
                    new Assertion(val, msg, assert.typeOf, !0).to.be.a(type)
                };
                assert.notTypeOf = function (val, type, msg) {
                    new Assertion(val, msg, assert.notTypeOf, !0).to.not.be.a(type)
                };
                assert.instanceOf = function (val, type, msg) {
                    new Assertion(val, msg, assert.instanceOf, !0).to.be.instanceOf(type)
                };
                assert.notInstanceOf = function (val, type, msg) {
                    new Assertion(val, msg, assert.notInstanceOf, !0).to.not.be.instanceOf(type)
                };
                assert.include = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.include, !0).include(inc)
                };
                assert.notInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notInclude, !0).not.include(inc)
                };
                assert.deepInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.deepInclude, !0).deep.include(inc)
                };
                assert.notDeepInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notDeepInclude, !0).not.deep.include(inc)
                };
                assert.nestedInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.nestedInclude, !0).nested.include(inc)
                };
                assert.notNestedInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notNestedInclude, !0).not.nested.include(inc)
                };
                assert.deepNestedInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.deepNestedInclude, !0).deep.nested.include(inc)
                };
                assert.notDeepNestedInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notDeepNestedInclude, !0).not.deep.nested.include(inc)
                };
                assert.ownInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.ownInclude, !0).own.include(inc)
                };
                assert.notOwnInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notOwnInclude, !0).not.own.include(inc)
                };
                assert.deepOwnInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.deepOwnInclude, !0).deep.own.include(inc)
                };
                assert.notDeepOwnInclude = function (exp, inc, msg) {
                    new Assertion(exp, msg, assert.notDeepOwnInclude, !0).not.deep.own.include(inc)
                };
                assert.match = function (exp, re, msg) {
                    new Assertion(exp, msg, assert.match, !0).to.match(re)
                };
                assert.notMatch = function (exp, re, msg) {
                    new Assertion(exp, msg, assert.notMatch, !0).to.not.match(re)
                };
                assert.property = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.property, !0).to.have.property(prop)
                };
                assert.notProperty = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.notProperty, !0).to.not.have.property(prop)
                };
                assert.propertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.propertyVal, !0).to.have.property(prop, val)
                };
                assert.notPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.notPropertyVal, !0).to.not.have.property(prop, val)
                };
                assert.deepPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.deepPropertyVal, !0).to.have.deep.property(prop, val)
                };
                assert.notDeepPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.notDeepPropertyVal, !0).to.not.have.deep.property(prop, val)
                };
                assert.ownProperty = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.ownProperty, !0).to.have.own.property(prop)
                };
                assert.notOwnProperty = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.notOwnProperty, !0).to.not.have.own.property(prop)
                };
                assert.ownPropertyVal = function (obj, prop, value, msg) {
                    new Assertion(obj, msg, assert.ownPropertyVal, !0).to.have.own.property(prop, value)
                };
                assert.notOwnPropertyVal = function (obj, prop, value, msg) {
                    new Assertion(obj, msg, assert.notOwnPropertyVal, !0).to.not.have.own.property(prop, value)
                };
                assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
                    new Assertion(obj, msg, assert.deepOwnPropertyVal, !0).to.have.deep.own.property(prop, value)
                };
                assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
                    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(prop, value)
                };
                assert.nestedProperty = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.nestedProperty, !0).to.have.nested.property(prop)
                };
                assert.notNestedProperty = function (obj, prop, msg) {
                    new Assertion(obj, msg, assert.notNestedProperty, !0).to.not.have.nested.property(prop)
                };
                assert.nestedPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.nestedPropertyVal, !0).to.have.nested.property(prop, val)
                };
                assert.notNestedPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.notNestedPropertyVal, !0).to.not.have.nested.property(prop, val)
                };
                assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.deepNestedPropertyVal, !0).to.have.deep.nested.property(prop, val)
                };
                assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
                    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(prop, val)
                }
                assert.lengthOf = function (exp, len, msg) {
                    new Assertion(exp, msg, assert.lengthOf, !0).to.have.lengthOf(len)
                };
                assert.hasAnyKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.hasAnyKeys, !0).to.have.any.keys(keys)
                }
                assert.hasAllKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.hasAllKeys, !0).to.have.all.keys(keys)
                }
                assert.containsAllKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.containsAllKeys, !0).to.contain.all.keys(keys)
                }
                assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, !0).to.not.have.any.keys(keys)
                }
                assert.doesNotHaveAllKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.doesNotHaveAllKeys, !0).to.not.have.all.keys(keys)
                }
                assert.hasAnyDeepKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.hasAnyDeepKeys, !0).to.have.any.deep.keys(keys)
                }
                assert.hasAllDeepKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.hasAllDeepKeys, !0).to.have.all.deep.keys(keys)
                }
                assert.containsAllDeepKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.containsAllDeepKeys, !0).to.contain.all.deep.keys(keys)
                }
                assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(keys)
                }
                assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
                    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(keys)
                }
                assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
                    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
                        errMsgMatcher = errorLike;
                        errorLike = null
                    }
                    var assertErr = new Assertion(fn, msg, assert.throws, !0).to.throw(errorLike, errMsgMatcher);
                    return flag(assertErr, 'object')
                };
                assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
                    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
                        errMsgMatcher = errorLike;
                        errorLike = null
                    }
                    new Assertion(fn, msg, assert.doesNotThrow, !0).to.not.throw(errorLike, errMsgMatcher)
                };
                assert.operator = function (val, operator, val2, msg) {
                    var ok;
                    switch (operator) {
                        case '==':
                            ok = val == val2;
                            break;
                        case '===':
                            ok = val === val2;
                            break;
                        case '>':
                            ok = val > val2;
                            break;
                        case '>=':
                            ok = val >= val2;
                            break;
                        case '<':
                            ok = val < val2;
                            break;
                        case '<=':
                            ok = val <= val2;
                            break;
                        case '!=':
                            ok = val != val2;
                            break;
                        case '!==':
                            ok = val !== val2;
                            break;
                        default:
                            msg = msg ? msg + ': ' : msg;
                            throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator)
                    }
                    var test = new Assertion(ok, msg, assert.operator, !0);
                    test.assert(!0 === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2))
                };
                assert.closeTo = function (act, exp, delta, msg) {
                    new Assertion(act, msg, assert.closeTo, !0).to.be.closeTo(exp, delta)
                };
                assert.approximately = function (act, exp, delta, msg) {
                    new Assertion(act, msg, assert.approximately, !0).to.be.approximately(exp, delta)
                };
                assert.sameMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.sameMembers, !0).to.have.same.members(set2)
                }
                assert.notSameMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.notSameMembers, !0).to.not.have.same.members(set2)
                }
                assert.sameDeepMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.sameDeepMembers, !0).to.have.same.deep.members(set2)
                }
                assert.notSameDeepMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.notSameDeepMembers, !0).to.not.have.same.deep.members(set2)
                }
                assert.sameOrderedMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.sameOrderedMembers, !0).to.have.same.ordered.members(set2)
                }
                assert.notSameOrderedMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.notSameOrderedMembers, !0).to.not.have.same.ordered.members(set2)
                }
                assert.sameDeepOrderedMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(set2)
                }
                assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
                    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(set2)
                }
                assert.includeMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.includeMembers, !0).to.include.members(subset)
                }
                assert.notIncludeMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.notIncludeMembers, !0).to.not.include.members(subset)
                }
                assert.includeDeepMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.includeDeepMembers, !0).to.include.deep.members(subset)
                }
                assert.notIncludeDeepMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.notIncludeDeepMembers, !0).to.not.include.deep.members(subset)
                }
                assert.includeOrderedMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.includeOrderedMembers, !0).to.include.ordered.members(subset)
                }
                assert.notIncludeOrderedMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.notIncludeOrderedMembers, !0).to.not.include.ordered.members(subset)
                }
                assert.includeDeepOrderedMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(subset)
                }
                assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
                    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(subset)
                }
                assert.oneOf = function (inList, list, msg) {
                    new Assertion(inList, msg, assert.oneOf, !0).to.be.oneOf(list)
                }
                assert.changes = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.changes, !0).to.change(obj, prop)
                }
                assert.changesBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.changesBy, !0).to.change(obj, prop).by(delta)
                }
                assert.doesNotChange = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.doesNotChange, !0).to.not.change(obj, prop)
                }
                assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.changesButNotBy, !0).to.change(obj, prop).but.not.by(delta)
                }
                assert.increases = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.increases, !0).to.increase(obj, prop)
                }
                assert.increasesBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.increasesBy, !0).to.increase(obj, prop).by(delta)
                }
                assert.doesNotIncrease = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.doesNotIncrease, !0).to.not.increase(obj, prop)
                }
                assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.increasesButNotBy, !0).to.increase(obj, prop).but.not.by(delta)
                }
                assert.decreases = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.decreases, !0).to.decrease(obj, prop)
                }
                assert.decreasesBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.decreasesBy, !0).to.decrease(obj, prop).by(delta)
                }
                assert.doesNotDecrease = function (fn, obj, prop, msg) {
                    if (arguments.length === 3 && typeof obj === 'function') {
                        msg = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.doesNotDecrease, !0).to.not.decrease(obj, prop)
                }
                assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    return new Assertion(fn, msg, assert.doesNotDecreaseBy, !0).to.not.decrease(obj, prop).by(delta)
                }
                assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
                    if (arguments.length === 4 && typeof obj === 'function') {
                        var tmpMsg = delta;
                        delta = prop;
                        msg = tmpMsg
                    } else if (arguments.length === 3) {
                        delta = prop;
                        prop = null
                    }
                    new Assertion(fn, msg, assert.decreasesButNotBy, !0).to.decrease(obj, prop).but.not.by(delta)
                }
                assert.ifError = function (val) {
                    if (val) {
                        throw(val)
                    }
                };
                assert.isExtensible = function (obj, msg) {
                    new Assertion(obj, msg, assert.isExtensible, !0).to.be.extensible
                };
                assert.isNotExtensible = function (obj, msg) {
                    new Assertion(obj, msg, assert.isNotExtensible, !0).to.not.be.extensible
                };
                assert.isSealed = function (obj, msg) {
                    new Assertion(obj, msg, assert.isSealed, !0).to.be.sealed
                };
                assert.isNotSealed = function (obj, msg) {
                    new Assertion(obj, msg, assert.isNotSealed, !0).to.not.be.sealed
                };
                assert.isFrozen = function (obj, msg) {
                    new Assertion(obj, msg, assert.isFrozen, !0).to.be.frozen
                };
                assert.isNotFrozen = function (obj, msg) {
                    new Assertion(obj, msg, assert.isNotFrozen, !0).to.not.be.frozen
                };
                assert.isEmpty = function (val, msg) {
                    new Assertion(val, msg, assert.isEmpty, !0).to.be.empty
                };
                assert.isNotEmpty = function (val, msg) {
                    new Assertion(val, msg, assert.isNotEmpty, !0).to.not.be.empty
                };
                (function alias(name, as) {
                    assert[as] = assert[name];
                    return alias
                })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty')
            }
        }, {}],
        7: [function (require, module, exports) {
            module.exports = function (chai, util) {
                chai.expect = function (val, message) {
                    return new chai.Assertion(val, message)
                };
                chai.expect.fail = function (actual, expected, message, operator) {
                    if (arguments.length < 2) {
                        message = actual;
                        actual = undefined
                    }
                    message = message || 'expect.fail()';
                    throw new chai.AssertionError(message, {
                        actual: actual,
                        expected: expected,
                        operator: operator
                    }, chai.expect.fail)
                }
            }
        }, {}],
        8: [function (require, module, exports) {
            module.exports = function (chai, util) {
                var Assertion = chai.Assertion;

                function loadShould() {
                    function shouldGetter() {
                        if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
                            return new Assertion(this.valueOf(), null, shouldGetter)
                        }
                        return new Assertion(this, null, shouldGetter)
                    }

                    function shouldSetter(value) {
                        Object.defineProperty(this, 'should', {
                            value: value,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        })
                    }

                    Object.defineProperty(Object.prototype, 'should', {
                        set: shouldSetter,
                        get: shouldGetter,
                        configurable: !0
                    });
                    var should = {};
                    should.fail = function (actual, expected, message, operator) {
                        if (arguments.length < 2) {
                            message = actual;
                            actual = undefined
                        }
                        message = message || 'should.fail()';
                        throw new chai.AssertionError(message, {
                            actual: actual,
                            expected: expected,
                            operator: operator
                        }, should.fail)
                    };
                    should.equal = function (val1, val2, msg) {
                        new Assertion(val1, msg).to.equal(val2)
                    };
                    should.Throw = function (fn, errt, errs, msg) {
                        new Assertion(fn, msg).to.Throw(errt, errs)
                    };
                    should.exist = function (val, msg) {
                        new Assertion(val, msg).to.exist
                    }
                    should.not = {}
                    should.not.equal = function (val1, val2, msg) {
                        new Assertion(val1, msg).to.not.equal(val2)
                    };
                    should.not.Throw = function (fn, errt, errs, msg) {
                        new Assertion(fn, msg).to.not.Throw(errt, errs)
                    };
                    should.not.exist = function (val, msg) {
                        new Assertion(val, msg).to.not.exist
                    }
                    should['throw'] = should.Throw;
                    should.not['throw'] = should.not.Throw;
                    return should
                };chai.should = loadShould;
                chai.Should = loadShould
            }
        }, {}],
        9: [function (require, module, exports) {
            var addLengthGuard = require('./addLengthGuard');
            var chai = require('../../chai');
            var flag = require('./flag');
            var proxify = require('./proxify');
            var transferFlags = require('./transferFlags');
            var canSetPrototype = typeof Object.setPrototypeOf === 'function';
            var testFn = function () {
            };
            var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
                var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
                if (typeof propDesc !== 'object')
                    return !0;
                return !propDesc.configurable
            });
            var call = Function.prototype.call, apply = Function.prototype.apply;
            module.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {
                if (typeof chainingBehavior !== 'function') {
                    chainingBehavior = function () {
                    }
                }
                var chainableBehavior = {method: method, chainingBehavior: chainingBehavior};
                if (!ctx.__methods) {
                    ctx.__methods = {}
                }
                ctx.__methods[name] = chainableBehavior;
                Object.defineProperty(ctx, name, {
                    get: function chainableMethodGetter() {
                        chainableBehavior.chainingBehavior.call(this);
                        var chainableMethodWrapper = function () {
                            if (!flag(this, 'lockSsfi')) {
                                flag(this, 'ssfi', chainableMethodWrapper)
                            }
                            var result = chainableBehavior.method.apply(this, arguments);
                            if (result !== undefined) {
                                return result
                            }
                            var newAssertion = new chai.Assertion();
                            transferFlags(this, newAssertion);
                            return newAssertion
                        };
                        addLengthGuard(chainableMethodWrapper, name, !0);
                        if (canSetPrototype) {
                            var prototype = Object.create(this);
                            prototype.call = call;
                            prototype.apply = apply;
                            Object.setPrototypeOf(chainableMethodWrapper, prototype)
                        } else {
                            var asserterNames = Object.getOwnPropertyNames(ctx);
                            asserterNames.forEach(function (asserterName) {
                                if (excludeNames.indexOf(asserterName) !== -1) {
                                    return
                                }
                                var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                                Object.defineProperty(chainableMethodWrapper, asserterName, pd)
                            })
                        }
                        transferFlags(this, chainableMethodWrapper);
                        return proxify(chainableMethodWrapper)
                    }, configurable: !0
                })
            }
        }, {"../../chai": 2, "./addLengthGuard": 10, "./flag": 15, "./proxify": 30, "./transferFlags": 32}],
        10: [function (require, module, exports) {
            var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {
            }, 'length');
            module.exports = function addLengthGuard(fn, assertionName, isChainable) {
                if (!fnLengthDesc.configurable) return fn;
                Object.defineProperty(fn, 'length', {
                    get: function () {
                        if (isChainable) {
                            throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.')
                        }
                        throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".')
                    }
                });
                return fn
            }
        }, {}],
        11: [function (require, module, exports) {
            var addLengthGuard = require('./addLengthGuard');
            var chai = require('../../chai');
            var flag = require('./flag');
            var proxify = require('./proxify');
            var transferFlags = require('./transferFlags');
            module.exports = function addMethod(ctx, name, method) {
                var methodWrapper = function () {
                    if (!flag(this, 'lockSsfi')) {
                        flag(this, 'ssfi', methodWrapper)
                    }
                    var result = method.apply(this, arguments);
                    if (result !== undefined)
                        return result;
                    var newAssertion = new chai.Assertion();
                    transferFlags(this, newAssertion);
                    return newAssertion
                };
                addLengthGuard(methodWrapper, name, !1);
                ctx[name] = proxify(methodWrapper, name)
            }
        }, {"../../chai": 2, "./addLengthGuard": 10, "./flag": 15, "./proxify": 30, "./transferFlags": 32}],
        12: [function (require, module, exports) {
            var chai = require('../../chai');
            var flag = require('./flag');
            var isProxyEnabled = require('./isProxyEnabled');
            var transferFlags = require('./transferFlags');
            module.exports = function addProperty(ctx, name, getter) {
                getter = getter === undefined ? function () {
                } : getter;
                Object.defineProperty(ctx, name, {
                    get: function propertyGetter() {
                        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
                            flag(this, 'ssfi', propertyGetter)
                        }
                        var result = getter.call(this);
                        if (result !== undefined)
                            return result;
                        var newAssertion = new chai.Assertion();
                        transferFlags(this, newAssertion);
                        return newAssertion
                    }, configurable: !0
                })
            }
        }, {"../../chai": 2, "./flag": 15, "./isProxyEnabled": 25, "./transferFlags": 32}],
        13: [function (require, module, exports) {
            var inspect = require('./inspect');
            module.exports = function compareByInspect(a, b) {
                return inspect(a) < inspect(b) ? -1 : 1
            }
        }, {"./inspect": 23}],
        14: [function (require, module, exports) {
            var AssertionError = require('assertion-error');
            var flag = require('./flag');
            var type = require('type-detect');
            module.exports = function expectTypes(obj, types) {
                var flagMsg = flag(obj, 'message');
                var ssfi = flag(obj, 'ssfi');
                flagMsg = flagMsg ? flagMsg + ': ' : '';
                obj = flag(obj, 'object');
                types = types.map(function (t) {
                    return t.toLowerCase()
                });
                types.sort();
                var str = types.map(function (t, index) {
                    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
                    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
                    return or + art + ' ' + t
                }).join(', ');
                var objType = type(obj).toLowerCase();
                if (!types.some(function (expected) {
                    return objType === expected
                })) {
                    throw new AssertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi)
                }
            }
        }, {"./flag": 15, "assertion-error": 33, "type-detect": 38}],
        15: [function (require, module, exports) {
            module.exports = function flag(obj, key, value) {
                var flags = obj.__flags || (obj.__flags = Object.create(null));
                if (arguments.length === 3) {
                    flags[key] = value
                } else {
                    return flags[key]
                }
            }
        }, {}],
        16: [function (require, module, exports) {
            module.exports = function getActual(obj, args) {
                return args.length > 4 ? args[4] : obj._obj
            }
        }, {}],
        17: [function (require, module, exports) {
            module.exports = function getEnumerableProperties(object) {
                var result = [];
                for (var name in object) {
                    result.push(name)
                }
                return result
            }
        }, {}],
        18: [function (require, module, exports) {
            var flag = require('./flag'), getActual = require('./getActual'), objDisplay = require('./objDisplay');
            module.exports = function getMessage(obj, args) {
                var negate = flag(obj, 'negate'), val = flag(obj, 'object'), expected = args[3],
                    actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, 'message');
                if (typeof msg === "function") msg = msg();
                msg = msg || '';
                msg = msg.replace(/#\{this\}/g, function () {
                    return objDisplay(val)
                }).replace(/#\{act\}/g, function () {
                    return objDisplay(actual)
                }).replace(/#\{exp\}/g, function () {
                    return objDisplay(expected)
                });
                return flagMsg ? flagMsg + ': ' + msg : msg
            }
        }, {"./flag": 15, "./getActual": 16, "./objDisplay": 26}],
        19: [function (require, module, exports) {
            var getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');
            module.exports = function getOwnEnumerableProperties(obj) {
                return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj))
            }
        }, {"./getOwnEnumerablePropertySymbols": 20}],
        20: [function (require, module, exports) {
            module.exports = function getOwnEnumerablePropertySymbols(obj) {
                if (typeof Object.getOwnPropertySymbols !== 'function') return [];
                return Object.getOwnPropertySymbols(obj).filter(function (sym) {
                    return Object.getOwnPropertyDescriptor(obj, sym).enumerable
                })
            }
        }, {}],
        21: [function (require, module, exports) {
            module.exports = function getProperties(object) {
                var result = Object.getOwnPropertyNames(object);

                function addProperty(property) {
                    if (result.indexOf(property) === -1) {
                        result.push(property)
                    }
                }

                var proto = Object.getPrototypeOf(object);
                while (proto !== null) {
                    Object.getOwnPropertyNames(proto).forEach(addProperty);
                    proto = Object.getPrototypeOf(proto)
                }
                return result
            }
        }, {}],
        22: [function (require, module, exports) {
            var pathval = require('pathval');
            exports.test = require('./test');
            exports.type = require('type-detect');
            exports.expectTypes = require('./expectTypes');
            exports.getMessage = require('./getMessage');
            exports.getActual = require('./getActual');
            exports.inspect = require('./inspect');
            exports.objDisplay = require('./objDisplay');
            exports.flag = require('./flag');
            exports.transferFlags = require('./transferFlags');
            exports.eql = require('deep-eql');
            exports.getPathInfo = pathval.getPathInfo;
            exports.hasProperty = pathval.hasProperty;
            exports.getName = require('get-func-name');
            exports.addProperty = require('./addProperty');
            exports.addMethod = require('./addMethod');
            exports.overwriteProperty = require('./overwriteProperty');
            exports.overwriteMethod = require('./overwriteMethod');
            exports.addChainableMethod = require('./addChainableMethod');
            exports.overwriteChainableMethod = require('./overwriteChainableMethod');
            exports.compareByInspect = require('./compareByInspect');
            exports.getOwnEnumerablePropertySymbols = require('./getOwnEnumerablePropertySymbols');
            exports.getOwnEnumerableProperties = require('./getOwnEnumerableProperties');
            exports.checkError = require('check-error');
            exports.proxify = require('./proxify');
            exports.addLengthGuard = require('./addLengthGuard');
            exports.isProxyEnabled = require('./isProxyEnabled');
            exports.isNaN = require('./isNaN')
        }, {
            "./addChainableMethod": 9,
            "./addLengthGuard": 10,
            "./addMethod": 11,
            "./addProperty": 12,
            "./compareByInspect": 13,
            "./expectTypes": 14,
            "./flag": 15,
            "./getActual": 16,
            "./getMessage": 18,
            "./getOwnEnumerableProperties": 19,
            "./getOwnEnumerablePropertySymbols": 20,
            "./inspect": 23,
            "./isNaN": 24,
            "./isProxyEnabled": 25,
            "./objDisplay": 26,
            "./overwriteChainableMethod": 27,
            "./overwriteMethod": 28,
            "./overwriteProperty": 29,
            "./proxify": 30,
            "./test": 31,
            "./transferFlags": 32,
            "check-error": 34,
            "deep-eql": 35,
            "get-func-name": 36,
            "pathval": 37,
            "type-detect": 38
        }],
        23: [function (require, module, exports) {
            var getName = require('get-func-name');
            var getProperties = require('./getProperties');
            var getEnumerableProperties = require('./getEnumerableProperties');
            var config = require('../config');
            module.exports = inspect;

            function inspect(obj, showHidden, depth, colors) {
                var ctx = {
                    showHidden: showHidden, seen: [], stylize: function (str) {
                        return str
                    }
                };
                return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth))
            }

            var isDOMElement = function (object) {
                if (typeof HTMLElement === 'object') {
                    return object instanceof HTMLElement
                } else {
                    return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string'
                }
            };

            function formatValue(ctx, value, recurseTimes) {
                if (value && typeof value.inspect === 'function' && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    if (typeof ret !== 'string') {
                        ret = formatValue(ctx, ret, recurseTimes)
                    }
                    return ret
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                    return primitive
                }
                if (isDOMElement(value)) {
                    if ('outerHTML' in value) {
                        return value.outerHTML
                    } else {
                        try {
                            if (document.xmlVersion) {
                                var xmlSerializer = new XMLSerializer();
                                return xmlSerializer.serializeToString(value)
                            } else {
                                var ns = "http://www.w3.org/1999/xhtml";
                                var container = document.createElementNS(ns, '_');
                                container.appendChild(value.cloneNode(!1));
                                var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
                                container.innerHTML = '';
                                return html
                            }
                        } catch (err) {
                        }
                    }
                }
                var visibleKeys = getEnumerableProperties(value);
                var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
                var name, nameSuffix;
                if (keys.length === 0 || (isError(value) && ((keys.length === 1 && keys[0] === 'stack') || (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')))) {
                    if (typeof value === 'function') {
                        name = getName(value);
                        nameSuffix = name ? ': ' + name : '';
                        return ctx.stylize('[Function' + nameSuffix + ']', 'special')
                    }
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
                    }
                    if (isDate(value)) {
                        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date')
                    }
                    if (isError(value)) {
                        return formatError(value)
                    }
                }
                var base = '', array = !1, typedArray = !1, braces = ['{', '}'];
                if (isTypedArray(value)) {
                    typedArray = !0;
                    braces = ['[', ']']
                }
                if (isArray(value)) {
                    array = !0;
                    braces = ['[', ']']
                }
                if (typeof value === 'function') {
                    name = getName(value);
                    nameSuffix = name ? ': ' + name : '';
                    base = ' [Function' + nameSuffix + ']'
                }
                if (isRegExp(value)) {
                    base = ' ' + RegExp.prototype.toString.call(value)
                }
                if (isDate(value)) {
                    base = ' ' + Date.prototype.toUTCString.call(value)
                }
                if (isError(value)) {
                    return formatError(value)
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                    return braces[0] + base + braces[1]
                }
                if (recurseTimes < 0) {
                    if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp')
                    } else {
                        return ctx.stylize('[Object]', 'special')
                    }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
                } else if (typedArray) {
                    return formatTypedArray(value)
                } else {
                    output = keys.map(function (key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
                    })
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces)
            }

            function formatPrimitive(ctx, value) {
                switch (typeof value) {
                    case 'undefined':
                        return ctx.stylize('undefined', 'undefined');
                    case 'string':
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    case 'number':
                        if (value === 0 && (1 / value) === -Infinity) {
                            return ctx.stylize('-0', 'number')
                        }
                        return ctx.stylize('' + value, 'number');
                    case 'boolean':
                        return ctx.stylize('' + value, 'boolean');
                    case 'symbol':
                        return ctx.stylize(value.toString(), 'symbol')
                }
                if (value === null) {
                    return ctx.stylize('null', 'null')
                }
            }

            function formatError(value) {
                return '[' + Error.prototype.toString.call(value) + ']'
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0))
                    } else {
                        output.push('')
                    }
                }
                keys.forEach(function (key) {
                    if (!key.match(/^\d+$/)) {
                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0))
                    }
                });
                return output
            }

            function formatTypedArray(value) {
                var str = '[ ';
                for (var i = 0; i < value.length; ++i) {
                    if (str.length >= config.truncateThreshold - 7) {
                        str += '...';
                        break
                    }
                    str += value[i] + ', '
                }
                str += ' ]';
                if (str.indexOf(',  ]') !== -1) {
                    str = str.replace(',  ]', ' ]')
                }
                return str
            }

            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name;
                var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
                var str;
                if (propDescriptor) {
                    if (propDescriptor.get) {
                        if (propDescriptor.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special')
                        } else {
                            str = ctx.stylize('[Getter]', 'special')
                        }
                    } else {
                        if (propDescriptor.set) {
                            str = ctx.stylize('[Setter]', 'special')
                        }
                    }
                }
                if (visibleKeys.indexOf(key) < 0) {
                    name = '[' + key + ']'
                }
                if (!str) {
                    if (ctx.seen.indexOf(value[key]) < 0) {
                        if (recurseTimes === null) {
                            str = formatValue(ctx, value[key], null)
                        } else {
                            str = formatValue(ctx, value[key], recurseTimes - 1)
                        }
                        if (str.indexOf('\n') > -1) {
                            if (array) {
                                str = str.split('\n').map(function (line) {
                                    return '  ' + line
                                }).join('\n').substr(2)
                            } else {
                                str = '\n' + str.split('\n').map(function (line) {
                                    return '   ' + line
                                }).join('\n')
                            }
                        }
                    } else {
                        str = ctx.stylize('[Circular]', 'special')
                    }
                }
                if (typeof name === 'undefined') {
                    if (array && key.match(/^\d+$/)) {
                        return str
                    }
                    name = JSON.stringify('' + key);
                    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                        name = name.substr(1, name.length - 2);
                        name = ctx.stylize(name, 'name')
                    } else {
                        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                        name = ctx.stylize(name, 'string')
                    }
                }
                return name + ': ' + str
            }

            function reduceToSingleString(output, base, braces) {
                var length = output.reduce(function (prev, cur) {
                    return prev + cur.length + 1
                }, 0);
                if (length > 60) {
                    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1]
                }
                return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
            }

            function isTypedArray(ar) {
                return (typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar)))
            }

            function isArray(ar) {
                return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]')
            }

            function isRegExp(re) {
                return typeof re === 'object' && objectToString(re) === '[object RegExp]'
            }

            function isDate(d) {
                return typeof d === 'object' && objectToString(d) === '[object Date]'
            }

            function isError(e) {
                return typeof e === 'object' && objectToString(e) === '[object Error]'
            }

            function objectToString(o) {
                return Object.prototype.toString.call(o)
            }
        }, {"../config": 4, "./getEnumerableProperties": 17, "./getProperties": 21, "get-func-name": 36}],
        24: [function (require, module, exports) {
            function isNaN(value) {
                return value !== value
            }

            module.exports = Number.isNaN || isNaN
        }, {}],
        25: [function (require, module, exports) {
            var config = require('../config');
            module.exports = function isProxyEnabled() {
                return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined'
            }
        }, {"../config": 4}],
        26: [function (require, module, exports) {
            var inspect = require('./inspect');
            var config = require('../config');
            module.exports = function objDisplay(obj) {
                var str = inspect(obj), type = Object.prototype.toString.call(obj);
                if (config.truncateThreshold && str.length >= config.truncateThreshold) {
                    if (type === '[object Function]') {
                        return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']'
                    } else if (type === '[object Array]') {
                        return '[ Array(' + obj.length + ') ]'
                    } else if (type === '[object Object]') {
                        var keys = Object.keys(obj),
                            kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
                        return '{ Object (' + kstr + ') }'
                    } else {
                        return str
                    }
                } else {
                    return str
                }
            }
        }, {"../config": 4, "./inspect": 23}],
        27: [function (require, module, exports) {
            var chai = require('../../chai');
            var transferFlags = require('./transferFlags');
            module.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
                var chainableBehavior = ctx.__methods[name];
                var _chainingBehavior = chainableBehavior.chainingBehavior;
                chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
                    var result = chainingBehavior(_chainingBehavior).call(this);
                    if (result !== undefined) {
                        return result
                    }
                    var newAssertion = new chai.Assertion();
                    transferFlags(this, newAssertion);
                    return newAssertion
                };
                var _method = chainableBehavior.method;
                chainableBehavior.method = function overwritingChainableMethodWrapper() {
                    var result = method(_method).apply(this, arguments);
                    if (result !== undefined) {
                        return result
                    }
                    var newAssertion = new chai.Assertion();
                    transferFlags(this, newAssertion);
                    return newAssertion
                }
            }
        }, {"../../chai": 2, "./transferFlags": 32}],
        28: [function (require, module, exports) {
            var addLengthGuard = require('./addLengthGuard');
            var chai = require('../../chai');
            var flag = require('./flag');
            var proxify = require('./proxify');
            var transferFlags = require('./transferFlags');
            module.exports = function overwriteMethod(ctx, name, method) {
                var _method = ctx[name], _super = function () {
                    throw new Error(name + ' is not a function')
                };
                if (_method && 'function' === typeof _method)
                    _super = _method;
                var overwritingMethodWrapper = function () {
                    if (!flag(this, 'lockSsfi')) {
                        flag(this, 'ssfi', overwritingMethodWrapper)
                    }
                    var origLockSsfi = flag(this, 'lockSsfi');
                    flag(this, 'lockSsfi', !0);
                    var result = method(_super).apply(this, arguments);
                    flag(this, 'lockSsfi', origLockSsfi);
                    if (result !== undefined) {
                        return result
                    }
                    var newAssertion = new chai.Assertion();
                    transferFlags(this, newAssertion);
                    return newAssertion
                }
                addLengthGuard(overwritingMethodWrapper, name, !1);
                ctx[name] = proxify(overwritingMethodWrapper, name)
            }
        }, {"../../chai": 2, "./addLengthGuard": 10, "./flag": 15, "./proxify": 30, "./transferFlags": 32}],
        29: [function (require, module, exports) {
            var chai = require('../../chai');
            var flag = require('./flag');
            var isProxyEnabled = require('./isProxyEnabled');
            var transferFlags = require('./transferFlags');
            module.exports = function overwriteProperty(ctx, name, getter) {
                var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = function () {
                };
                if (_get && 'function' === typeof _get.get)
                    _super = _get.get
                Object.defineProperty(ctx, name, {
                    get: function overwritingPropertyGetter() {
                        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
                            flag(this, 'ssfi', overwritingPropertyGetter)
                        }
                        var origLockSsfi = flag(this, 'lockSsfi');
                        flag(this, 'lockSsfi', !0);
                        var result = getter(_super).call(this);
                        flag(this, 'lockSsfi', origLockSsfi);
                        if (result !== undefined) {
                            return result
                        }
                        var newAssertion = new chai.Assertion();
                        transferFlags(this, newAssertion);
                        return newAssertion
                    }, configurable: !0
                })
            }
        }, {"../../chai": 2, "./flag": 15, "./isProxyEnabled": 25, "./transferFlags": 32}],
        30: [function (require, module, exports) {
            var config = require('../config');
            var flag = require('./flag');
            var getProperties = require('./getProperties');
            var isProxyEnabled = require('./isProxyEnabled');
            var builtins = ['__flags', '__methods', '_obj', 'assert'];
            module.exports = function proxify(obj, nonChainableMethodName) {
                if (!isProxyEnabled()) return obj;
                return new Proxy(obj, {
                    get: function proxyGetter(target, property) {
                        if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
                            if (nonChainableMethodName) {
                                throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".')
                            }
                            var suggestion = null;
                            var suggestionDistance = 4;
                            getProperties(target).forEach(function (prop) {
                                if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
                                    var dist = stringDistanceCapped(property, prop, suggestionDistance);
                                    if (dist < suggestionDistance) {
                                        suggestion = prop;
                                        suggestionDistance = dist
                                    }
                                }
                            });
                            if (suggestion !== null) {
                                throw Error('Invalid Chai property: ' + property + '. Did you mean "' + suggestion + '"?')
                            } else {
                                throw Error('Invalid Chai property: ' + property)
                            }
                        }
                        if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
                            flag(target, 'ssfi', proxyGetter)
                        }
                        return Reflect.get(target, property)
                    }
                })
            };

            function stringDistanceCapped(strA, strB, cap) {
                if (Math.abs(strA.length - strB.length) >= cap) {
                    return cap
                }
                var memo = [];
                for (var i = 0; i <= strA.length; i++) {
                    memo[i] = Array(strB.length + 1).fill(0);
                    memo[i][0] = i
                }
                for (var j = 0; j < strB.length; j++) {
                    memo[0][j] = j
                }
                for (var i = 1; i <= strA.length; i++) {
                    var ch = strA.charCodeAt(i - 1);
                    for (var j = 1; j <= strB.length; j++) {
                        if (Math.abs(i - j) >= cap) {
                            memo[i][j] = cap;
                            continue
                        }
                        memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1))
                    }
                }
                return memo[strA.length][strB.length]
            }
        }, {"../config": 4, "./flag": 15, "./getProperties": 21, "./isProxyEnabled": 25}],
        31: [function (require, module, exports) {
            var flag = require('./flag');
            module.exports = function test(obj, args) {
                var negate = flag(obj, 'negate'), expr = args[0];
                return negate ? !expr : expr
            }
        }, {"./flag": 15}],
        32: [function (require, module, exports) {
            module.exports = function transferFlags(assertion, object, includeAll) {
                var flags = assertion.__flags || (assertion.__flags = Object.create(null));
                if (!object.__flags) {
                    object.__flags = Object.create(null)
                }
                includeAll = arguments.length === 3 ? includeAll : !0;
                for (var flag in flags) {
                    if (includeAll || (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {
                        object.__flags[flag] = flags[flag]
                    }
                }
            }
        }, {}],
        33: [function (require, module, exports) {
            function exclude() {
                var excludes = [].slice.call(arguments);

                function excludeProps(res, obj) {
                    Object.keys(obj).forEach(function (key) {
                        if (!~excludes.indexOf(key)) res[key] = obj[key]
                    })
                }

                return function extendExclude() {
                    var args = [].slice.call(arguments), i = 0, res = {};
                    for (; i < args.length; i++) {
                        excludeProps(res, args[i])
                    }
                    return res
                }
            };module.exports = AssertionError;

            function AssertionError(message, _props, ssf) {
                var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'), props = extend(_props || {});
                this.message = message || 'Unspecified AssertionError';
                this.showDiff = !1;
                for (var key in props) {
                    this[key] = props[key]
                }
                ssf = ssf || AssertionError;
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, ssf)
                } else {
                    try {
                        throw new Error()
                    } catch (e) {
                        this.stack = e.stack
                    }
                }
            }

            AssertionError.prototype = Object.create(Error.prototype);
            AssertionError.prototype.name = 'AssertionError';
            AssertionError.prototype.constructor = AssertionError;
            AssertionError.prototype.toJSON = function (stack) {
                var extend = exclude('constructor', 'toJSON', 'stack'), props = extend({name: this.name}, this);
                if (!1 !== stack && this.stack) {
                    props.stack = this.stack
                }
                return props
            }
        }, {}],
        34: [function (require, module, exports) {
            'use strict';

            function compatibleInstance(thrown, errorLike) {
                return errorLike instanceof Error && thrown === errorLike
            }

            function compatibleConstructor(thrown, errorLike) {
                if (errorLike instanceof Error) {
                    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor
                } else if (errorLike.prototype instanceof Error || errorLike === Error) {
                    return thrown.constructor === errorLike || thrown instanceof errorLike
                }
                return !1
            }

            function compatibleMessage(thrown, errMatcher) {
                var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
                if (errMatcher instanceof RegExp) {
                    return errMatcher.test(comparisonString)
                } else if (typeof errMatcher === 'string') {
                    return comparisonString.indexOf(errMatcher) !== -1
                }
                return !1
            }

            var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

            function getFunctionName(constructorFn) {
                var name = '';
                if (typeof constructorFn.name === 'undefined') {
                    var match = String(constructorFn).match(functionNameMatch);
                    if (match) {
                        name = match[1]
                    }
                } else {
                    name = constructorFn.name
                }
                return name
            }

            function getConstructorName(errorLike) {
                var constructorName = errorLike;
                if (errorLike instanceof Error) {
                    constructorName = getFunctionName(errorLike.constructor)
                } else if (typeof errorLike === 'function') {
                    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike())
                }
                return constructorName
            }

            function getMessage(errorLike) {
                var msg = '';
                if (errorLike && errorLike.message) {
                    msg = errorLike.message
                } else if (typeof errorLike === 'string') {
                    msg = errorLike
                }
                return msg
            }

            module.exports = {
                compatibleInstance: compatibleInstance,
                compatibleConstructor: compatibleConstructor,
                compatibleMessage: compatibleMessage,
                getMessage: getMessage,
                getConstructorName: getConstructorName,
            }
        }, {}],
        35: [function (require, module, exports) {
            'use strict';
            var type = require('type-detect');

            function FakeMap() {
                this._key = 'chai/deep-eql__' + Math.random() + Date.now()
            }

            FakeMap.prototype = {
                get: function getMap(key) {
                    return key[this._key]
                }, set: function setMap(key, value) {
                    if (Object.isExtensible(key)) {
                        Object.defineProperty(key, this._key, {value: value, configurable: !0,})
                    }
                },
            };
            var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;

            function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
                if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
                    return null
                }
                var leftHandMap = memoizeMap.get(leftHandOperand);
                if (leftHandMap) {
                    var result = leftHandMap.get(rightHandOperand);
                    if (typeof result === 'boolean') {
                        return result
                    }
                }
                return null
            }

            function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
                if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
                    return
                }
                var leftHandMap = memoizeMap.get(leftHandOperand);
                if (leftHandMap) {
                    leftHandMap.set(rightHandOperand, result)
                } else {
                    leftHandMap = new MemoizeMap();
                    leftHandMap.set(rightHandOperand, result);
                    memoizeMap.set(leftHandOperand, leftHandMap)
                }
            }

            module.exports = deepEqual;
            module.exports.MemoizeMap = MemoizeMap;

            function deepEqual(leftHandOperand, rightHandOperand, options) {
                if (options && options.comparator) {
                    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options)
                }
                var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
                if (simpleResult !== null) {
                    return simpleResult
                }
                return extensiveDeepEqual(leftHandOperand, rightHandOperand, options)
            }

            function simpleEqual(leftHandOperand, rightHandOperand) {
                if (leftHandOperand === rightHandOperand) {
                    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand
                }
                if (leftHandOperand !== leftHandOperand && rightHandOperand !== rightHandOperand) {
                    return !0
                }
                if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
                    return !1
                }
                return null
            }

            function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
                options = options || {};
                options.memoize = options.memoize === !1 ? !1 : options.memoize || new MemoizeMap();
                var comparator = options && options.comparator;
                var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
                if (memoizeResultLeft !== null) {
                    return memoizeResultLeft
                }
                var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
                if (memoizeResultRight !== null) {
                    return memoizeResultRight
                }
                if (comparator) {
                    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
                    if (comparatorResult === !1 || comparatorResult === !0) {
                        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
                        return comparatorResult
                    }
                    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
                    if (simpleResult !== null) {
                        return simpleResult
                    }
                }
                var leftHandType = type(leftHandOperand);
                if (leftHandType !== type(rightHandOperand)) {
                    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !1);
                    return !1
                }
                memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !0);
                var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
                memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
                return result
            }

            function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
                switch (leftHandType) {
                    case 'String':
                    case 'Number':
                    case 'Boolean':
                    case 'Date':
                        return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
                    case 'Promise':
                    case 'Symbol':
                    case 'function':
                    case 'WeakMap':
                    case 'WeakSet':
                    case 'Error':
                        return leftHandOperand === rightHandOperand;
                    case 'Arguments':
                    case 'Int8Array':
                    case 'Uint8Array':
                    case 'Uint8ClampedArray':
                    case 'Int16Array':
                    case 'Uint16Array':
                    case 'Int32Array':
                    case 'Uint32Array':
                    case 'Float32Array':
                    case 'Float64Array':
                    case 'Array':
                        return iterableEqual(leftHandOperand, rightHandOperand, options);
                    case 'RegExp':
                        return regexpEqual(leftHandOperand, rightHandOperand);
                    case 'Generator':
                        return generatorEqual(leftHandOperand, rightHandOperand, options);
                    case 'DataView':
                        return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
                    case 'ArrayBuffer':
                        return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
                    case 'Set':
                        return entriesEqual(leftHandOperand, rightHandOperand, options);
                    case 'Map':
                        return entriesEqual(leftHandOperand, rightHandOperand, options);
                    default:
                        return objectEqual(leftHandOperand, rightHandOperand, options)
                }
            }

            function regexpEqual(leftHandOperand, rightHandOperand) {
                return leftHandOperand.toString() === rightHandOperand.toString()
            }

            function entriesEqual(leftHandOperand, rightHandOperand, options) {
                if (leftHandOperand.size !== rightHandOperand.size) {
                    return !1
                }
                if (leftHandOperand.size === 0) {
                    return !0
                }
                var leftHandItems = [];
                var rightHandItems = [];
                leftHandOperand.forEach(function gatherEntries(key, value) {
                    leftHandItems.push([key, value])
                });
                rightHandOperand.forEach(function gatherEntries(key, value) {
                    rightHandItems.push([key, value])
                });
                return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options)
            }

            function iterableEqual(leftHandOperand, rightHandOperand, options) {
                var length = leftHandOperand.length;
                if (length !== rightHandOperand.length) {
                    return !1
                }
                if (length === 0) {
                    return !0
                }
                var index = -1;
                while (++index < length) {
                    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === !1) {
                        return !1
                    }
                }
                return !0
            }

            function generatorEqual(leftHandOperand, rightHandOperand, options) {
                return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options)
            }

            function hasIteratorFunction(target) {
                return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function'
            }

            function getIteratorEntries(target) {
                if (hasIteratorFunction(target)) {
                    try {
                        return getGeneratorEntries(target[Symbol.iterator]())
                    } catch (iteratorError) {
                        return []
                    }
                }
                return []
            }

            function getGeneratorEntries(generator) {
                var generatorResult = generator.next();
                var accumulator = [generatorResult.value];
                while (generatorResult.done === !1) {
                    generatorResult = generator.next();
                    accumulator.push(generatorResult.value)
                }
                return accumulator
            }

            function getEnumerableKeys(target) {
                var keys = [];
                for (var key in target) {
                    keys.push(key)
                }
                return keys
            }

            function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
                var length = keys.length;
                if (length === 0) {
                    return !0
                }
                for (var i = 0; i < length; i += 1) {
                    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === !1) {
                        return !1
                    }
                }
                return !0
            }

            function objectEqual(leftHandOperand, rightHandOperand, options) {
                var leftHandKeys = getEnumerableKeys(leftHandOperand);
                var rightHandKeys = getEnumerableKeys(rightHandOperand);
                if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
                    leftHandKeys.sort();
                    rightHandKeys.sort();
                    if (iterableEqual(leftHandKeys, rightHandKeys) === !1) {
                        return !1
                    }
                    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options)
                }
                var leftHandEntries = getIteratorEntries(leftHandOperand);
                var rightHandEntries = getIteratorEntries(rightHandOperand);
                if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
                    leftHandEntries.sort();
                    rightHandEntries.sort();
                    return iterableEqual(leftHandEntries, rightHandEntries, options)
                }
                if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
                    return !0
                }
                return !1
            }

            function isPrimitive(value) {
                return value === null || typeof value !== 'object'
            }
        }, {"type-detect": 38}],
        36: [function (require, module, exports) {
            'use strict';
            var toString = Function.prototype.toString;
            var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

            function getFuncName(aFunc) {
                if (typeof aFunc !== 'function') {
                    return null
                }
                var name = '';
                if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
                    var match = toString.call(aFunc).match(functionNameMatch);
                    if (match) {
                        name = match[1]
                    }
                } else {
                    name = aFunc.name
                }
                return name
            }

            module.exports = getFuncName
        }, {}],
        37: [function (require, module, exports) {
            'use strict';

            function hasProperty(obj, name) {
                if (typeof obj === 'undefined' || obj === null) {
                    return !1
                }
                return name in Object(obj)
            }

            function parsePath(path) {
                var str = path.replace(/([^\\])\[/g, '$1.[');
                var parts = str.match(/(\\\.|[^.]+?)+/g);
                return parts.map(function mapMatches(value) {
                    var regexp = /^\[(\d+)\]$/;
                    var mArr = regexp.exec(value);
                    var parsed = null;
                    if (mArr) {
                        parsed = {i: parseFloat(mArr[1])}
                    } else {
                        parsed = {p: value.replace(/\\([.\[\]])/g, '$1')}
                    }
                    return parsed
                })
            }

            function internalGetPathValue(obj, parsed, pathDepth) {
                var temporaryValue = obj;
                var res = null;
                pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);
                for (var i = 0; i < pathDepth; i++) {
                    var part = parsed[i];
                    if (temporaryValue) {
                        if (typeof part.p === 'undefined') {
                            temporaryValue = temporaryValue[part.i]
                        } else {
                            temporaryValue = temporaryValue[part.p]
                        }
                        if (i === (pathDepth - 1)) {
                            res = temporaryValue
                        }
                    }
                }
                return res
            }

            function internalSetPathValue(obj, val, parsed) {
                var tempObj = obj;
                var pathDepth = parsed.length;
                var part = null;
                for (var i = 0; i < pathDepth; i++) {
                    var propName = null;
                    var propVal = null;
                    part = parsed[i];
                    if (i === (pathDepth - 1)) {
                        propName = typeof part.p === 'undefined' ? part.i : part.p;
                        tempObj[propName] = val
                    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
                        tempObj = tempObj[part.p]
                    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
                        tempObj = tempObj[part.i]
                    } else {
                        var next = parsed[i + 1];
                        propName = typeof part.p === 'undefined' ? part.i : part.p;
                        propVal = typeof next.p === 'undefined' ? [] : {};
                        tempObj[propName] = propVal;
                        tempObj = tempObj[propName]
                    }
                }
            }

            function getPathInfo(obj, path) {
                var parsed = parsePath(path);
                var last = parsed[parsed.length - 1];
                var info = {
                    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
                    name: last.p || last.i,
                    value: internalGetPathValue(obj, parsed),
                };
                info.exists = hasProperty(info.parent, info.name);
                return info
            }

            function getPathValue(obj, path) {
                var info = getPathInfo(obj, path);
                return info.value
            }

            function setPathValue(obj, path, val) {
                var parsed = parsePath(path);
                internalSetPathValue(obj, val, parsed);
                return obj
            }

            module.exports = {
                hasProperty: hasProperty,
                getPathInfo: getPathInfo,
                getPathValue: getPathValue,
                setPathValue: setPathValue,
            }
        }, {}],
        38: [function (require, module, exports) {
            (function (global, factory) {
                typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global.typeDetect = factory())
            }(this, (function () {
                'use strict';
                var promiseExists = typeof Promise === 'function';
                var globalObject = typeof self === 'object' ? self : global;
                var symbolExists = typeof Symbol !== 'undefined';
                var mapExists = typeof Map !== 'undefined';
                var setExists = typeof Set !== 'undefined';
                var weakMapExists = typeof WeakMap !== 'undefined';
                var weakSetExists = typeof WeakSet !== 'undefined';
                var dataViewExists = typeof DataView !== 'undefined';
                var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
                var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
                var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
                var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
                var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
                var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
                var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
                var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
                var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
                var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
                var toStringLeftSliceLength = 8;
                var toStringRightSliceLength = -1;

                function typeDetect(obj) {
                    var typeofObj = typeof obj;
                    if (typeofObj !== 'object') {
                        return typeofObj
                    }
                    if (obj === null) {
                        return 'null'
                    }
                    if (obj === globalObject) {
                        return 'global'
                    }
                    if (Array.isArray(obj) && (symbolToStringTagExists === !1 || !(Symbol.toStringTag in obj))) {
                        return 'Array'
                    }
                    if (typeof window === 'object' && window !== null) {
                        if (typeof window.location === 'object' && obj === window.location) {
                            return 'Location'
                        }
                        if (typeof window.document === 'object' && obj === window.document) {
                            return 'Document'
                        }
                        if (typeof window.navigator === 'object') {
                            if (typeof window.navigator.mimeTypes === 'object' && obj === window.navigator.mimeTypes) {
                                return 'MimeTypeArray'
                            }
                            if (typeof window.navigator.plugins === 'object' && obj === window.navigator.plugins) {
                                return 'PluginArray'
                            }
                        }
                        if ((typeof window.HTMLElement === 'function' || typeof window.HTMLElement === 'object') && obj instanceof window.HTMLElement) {
                            if (obj.tagName === 'BLOCKQUOTE') {
                                return 'HTMLQuoteElement'
                            }
                            if (obj.tagName === 'TD') {
                                return 'HTMLTableDataCellElement'
                            }
                            if (obj.tagName === 'TH') {
                                return 'HTMLTableHeaderCellElement'
                            }
                        }
                    }
                    var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
                    if (typeof stringTag === 'string') {
                        return stringTag
                    }
                    var objPrototype = Object.getPrototypeOf(obj);
                    if (objPrototype === RegExp.prototype) {
                        return 'RegExp'
                    }
                    if (objPrototype === Date.prototype) {
                        return 'Date'
                    }
                    if (promiseExists && objPrototype === Promise.prototype) {
                        return 'Promise'
                    }
                    if (setExists && objPrototype === Set.prototype) {
                        return 'Set'
                    }
                    if (mapExists && objPrototype === Map.prototype) {
                        return 'Map'
                    }
                    if (weakSetExists && objPrototype === WeakSet.prototype) {
                        return 'WeakSet'
                    }
                    if (weakMapExists && objPrototype === WeakMap.prototype) {
                        return 'WeakMap'
                    }
                    if (dataViewExists && objPrototype === DataView.prototype) {
                        return 'DataView'
                    }
                    if (mapExists && objPrototype === mapIteratorPrototype) {
                        return 'Map Iterator'
                    }
                    if (setExists && objPrototype === setIteratorPrototype) {
                        return 'Set Iterator'
                    }
                    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
                        return 'Array Iterator'
                    }
                    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
                        return 'String Iterator'
                    }
                    if (objPrototype === null) {
                        return 'Object'
                    }
                    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength)
                }

                return typeDetect
            })))
        }, {}]
    }, {}, [1])(1)
})